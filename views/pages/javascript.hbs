{{setTitle "Intl Message Format API"}}
<h1>The Intl Message Format API</h1>

{{sectionHeading "Overview"}}

<p>
    The IntlMessageFormat API aims to provide a standardized way to concatenate strings with localization support in JavaScript on both the server and client. It allows you to format a string with placeholders, including plural and select support to create localized messages.
</p>

<aside>
    <p>
        The {{code "intl-messageformat"}} module can be used by itself, but it is mainly intended to be used within the 3 helpers we have provided. You should start your development using either the <a href="/handlebars">Handlebars</a>, <a href="/dust">Dust</a>, or <a href="/react">React</a> helpers
        if you are using those in your project.
    </p>
</aside>

{{sectionHeading "How It Works"}}

<p>Messages are provided into the constructor as an {{code "Array"}} or {{code "String"}} messages.</p>

{{#code "js"}}
var msg = new IntlMessageFormat(pattern, locale, [optFieldFormatters]);
{{/code}}


<p>
    The pattern is stored internally until the {{code "format()"}} method is called with an {{code "Object"}} containing parameters for generating the message. The pattern is then processed by converting the tokens into strings based on the parameters provided and concatenating the values together.
</p>


{{sectionHeading "Features"}}

<p>
    Custom formatters can be used to format the value <em>after</em> it is gathered from the original process. Custom formatters are stored in the message during construction as the third parameter. Formatters are denoted in the argument with a comma (,) followed by the formatter name.
</p>

<p>For example you can ensure that certain tokens are always upper cased:</p>

{{#code "js"}}
var msg = new IntlMessageFormat("Then they yelled '{YELL, upper}!'", "en", {
    "upper": function (val, locale) {
        return val.toString().toUpperCase();
    }
});

var m = msg.format({ YELL: "suprise" });

// Then they yelled 'SUPRISE!'
{{/code}}


{{sectionHeading "Installation"}}

You can install {{code "intl-messageformat"}} via npm:

{{#code "shell"}}
npm install intl-messageformat
{{/code}}


{{sectionHeading "Usage"}}

<h3>IntlMessageFormat Constructor</h3>

<p>
    To create a message to format, use the IntlMessageFormat constructor. The constructor has three parameters:
</p>

<dl class="parameters-list">
    <dt>{{code "pattern: String"}}</dt>
    <dd>String that serves as formatting pattern.</dd>

    <dt>{{code "locale: String"}}</dt>
    <dd>Locale for string formatting. The locale is optional, but it is highly encouraged to provide a locale. If you do not provide a locale, the default locale will be used.</dd>

    <dt>{{code "optFieldFormatters: Object"}}</dt>
    <dd>(optional) Holds user defined formatters for each field</dd>
</dl>

<h3>Creating a Message in Node.js</h3>

{{#code "js"}}
var IntlMessageFormat = require('intl-messageformat');

// load some locales that you care about
require('intl-messageformat/locale-data/en');
require('intl-messageformat/locale-data/ar');
require('intl-messageformat/locale-data/pl');

var msg = new IntlMessageFormat("My name is {NAME}.", "en-US");
{{/code}}

<h3>Creating a Message in a Browser</h3>
{{#code "js"}}
var msg = new IntlMessageFormat("My name is {NAME}.", "en-US");
{{/code}}

<h3>Formatting a Message</h3>

<p>
    Once the message is created, formatting the message is done by calling the {{code "format()"}} method of the instantiated object:
</p>

{{#code "js"}}
var myNameIs = msg.format({ NAME: "Ferris Wheeler"});

// "My name is Ferris Wheeler."
{{/code}}




{{sectionHeading "API"}}

<h3>Constructor</h3>

<p>
    Creates an IntlMessageFormat object from a pattern, locale and field formatters. String patterns are broken down to Arrays. Objects should match the following pattern:
</p>

{{#code "js"}}
{
    type: 'plural|select',
    valueName: 'string',
    offset: 1, // consistent offsets for plurals
    options: {}, // keys match options for plurals and selects
    format: 'string|function' // strings are matched to internal formatters
}
{{/code}}

<h3>Parameters</h3>

<dl class="parameters-list">

    <dt>{{code "pattern: String"}}</dt>
    <dd>
        {{code "String"}} that serves as formatting pattern.
    </dd>

    <dt>{{code "locale: String"}}</dt>
    <dd>
        Locale for string formatting and when using plurals and formatters.
    </dd>

    <dt>{{code "optFieldFormatters: Object"}}</dt>
    <dd>Holds user defined formatters for each field</dd>

</dl>

<h3>Instance Methods</h3>

<h4>{{code "format(data)"}}</h4>
<p>
    Formats the pattern with supplied parameters. Dates, times and numbers are formatted in locale sensitive way when used with a formatter.
</p>

<strong>Parameters</strong>

<dl class="parameters-list">
    <dt>{{code "data: Object"}}</dt>
    <dd>Object used to choose options when formatting the message</dd>
    <dt>{{code "resolvedOptions"}}</dt>
    <dd><em>NOT YET DETERMINED:</em> Returns resolved options, in this case supported locale.</dd>
</dl>




{{sectionHeading "Locale Data"}}

<p>
    This package ships with locale data for the top-level locales (e.g. {{code "en"}} but not {{code "en-US"}}). You can load the library and locale(s) using any of the following subpaths in the package:
</p>

<ul>
    <li>Load the base and then just the locale(s) that you need: {{code "intl-messageformat/index.js"}} and {{code "intl-messageformat/locale-data/{locale}.js"}}</li>

    <li>Load the base with a single locale builtin: {{code "intl-messageformat/build/intl-messageformat.{locale}.js')"}}. You can then optionally add more locale(s) as above.</li>

    <li>Load all locales: {{code "intl-messageformat/build/intl-messageformat.complete.js"}}</li>
</ul>


<h3>Loading Locale Data in Node.js</h3>

<p>
    <strong>Please note</strong> that if you are loading from the {{code "locale-data/"}} directory that those files are expecting the library to be available in the {{code "IntlMessageFormat"}} variable.
</p>

<h3>Loading Locale Data in a Browser</h3>

<p>
    Every {{code "intl-messageformat/build/*.js"}} file also has an {{code "intl-messageformat/build/*.min.js"}} equivalent which has already been minified.
</p>


{{sectionHeading "Examples"}}

<h3>Simple String</h3>
{{#code "js"}}
var msg = new IntlMessageFormat("My name is {name}.", "en-US");

var myNameIs = msg.format({ name: "Ferris Wheeler"});

// "My name is Ferris Wheeler."
{{/code}}


<h3>Complex Formatting</h3>
{{#code "js"}}
var msg = new IntlMessageFormat(['Some text before ', {
    type: 'plural',
    valueName: 'NUM_PEOPLE',
    offset: 1,
    options: {
        one: 'Some message ${PH} with ${#} value',

        few: ['Optional prefix text for |few| ', {
            type: 'select',
            valueName: 'GENDER',
            options: {
                male: 'Text for male option with \' single quotes',
                female: 'Text for female option with {}',
                other: 'Text for default'
            }
        }, ' optional postfix text'],

        other: 'Some messages for the default'
    }
}, ' and text after'], "en-US");

var complex = msg.format({
    NUM_PEOPLE: 4,
    PH: 'whatever',
    GENDER: 'male'
});

// "Some text before Optional prefix text for |few| Text for male option with ' single quotes optional postfix text and text after"
{{/code}}

<h3>User Defined Formatters</h3>
<p>
    User defined formatters are provided to the IntlMessageFormat as the third parameter. To denote a key should be process through a formatter, you need only provide the formatter name after the token key. Such as, {{code "{key}"}} would then become {{code "{key, formatter}"}}. This is an example of using the Intl.NumberFormat to create a currency formatter.
</p>

{{#code "js"}}
var msg = new IntlMessageFormatter("I just made {TOTAL, currency}!!", "en-US", {
    currency: function (val, locale) {
        return new Intl.NumberFormat(val, {
            style: 'currency',
            currency: 'USD',
            currencyDisplay: 'symbol'
        });
    }
});

var payday = msg.format({ TOTAL: 3 });

// I just made $3.00!!
{{/code}}
